# 掌握扫描线(sweep line)算法：从LeetCode到现实应用

扫描线(sweep line)算法是编程面试中常出现的“隐藏宝石”，同时也悄悄地为许多现实应用提供支持——从日程安排到几何计算等。本文将揭示它的工作原理，展示如何在C#中使用`SortedDictionary`实现，并探讨它在实际应用中的光辉时刻。

---

## 🟢 1. 扫描线简介

想象一下，你站在时间线或二维空间的左边缘，拖动一条从左到右的垂直线。每当这条线触碰到一些重要的东西——比如事件的开始或结束——你就“处理”这个事件。这就是扫描线技术的本质。

与其盲目扫描所有元素，我们将数据**预处理为已排序的事件**（如区间的开始/结束，或二维空间中的点），然后使用高效的数据结构来**跟踪扫描线移动时的当前状态**。

### 🧠 工作原理

- **步骤1：转换** 区间、矩形或对象为一组事件（开始和结束点）。
- **步骤2：排序** 所有事件，按照它们的位置排序（通常是X坐标或时间）。
- **步骤3：扫描** 按顺序处理这些事件，更新动态数据结构（如计数器、堆或集合）。
- **步骤4：处理** 逻辑需求——重叠、交集、空闲时间等。

### 📈 可视化示例

假设我们要找到**最大重叠会议数量**：

给定会议：

``` plaintext
会议 A: [1, 5)
会议 B: [2, 6)
会议 C: [4, 7)
```

``` plaintext
时间:     1   2   3   4   5   6   7
          |---|---|---|---|---|---|
A:        [===============)
B:            [===============)
C:                    [===========)
```

事件：

``` plaintext
+1 在 1（A开始）
+1 在 2（B开始）
+1 在 4（C开始）
-1 在 5（A结束）
-1 在 6（B结束）
-1 在 7（C结束）
```

随着扫描：

- 在时间 1: 活跃 = 1  
- 在时间 2: 活跃 = 2  
- 在时间 4: 活跃 = 3 ✅ 最大值
- 在时间 5: 活跃 = 2  
- ...

---

## ⚙️ 2. 使用`SortedDictionary`进行扫描线操作（C#）

在C#中，`SortedDictionary<int, int>`是一个跟踪事件计数的好方法。它保持键的排序，并允许O(log n)的插入和查找操作。

### 🧪 示例：查找最大重叠数

```csharp
public int MaxOverlap(int[][] intervals) {
    var timeline = new SortedDictionary<int, int>();

    foreach (var interval in intervals) {
        int start = interval[0], end = interval[1];
        timeline[start] = timeline.GetValueOrDefault(start, 0) + 1;
        timeline[end] = timeline.GetValueOrDefault(end, 0) - 1;
    }

    int active = 0, max = 0;
    foreach (var kvp in timeline) {
        active += kvp.Value;
        max = Math.Max(max, active);
    }

    return max;
}
```

### 🧭 解释

- 我们在每个开始点标记`+1`，在每个结束点标记`-1`。
- 然后我们扫描排序好的时间线，调整活跃计数。
- `active`的峰值就是我们的答案。

这个技术非常适合：

- 计数重叠事件
- 资源跟踪
- 管理并发任务

---

## 🌍 3. 实际应用场景

扫描线技术不仅仅是玩具问题，它在多个行业的实际系统中都有应用：

### 📅 日历与调度

- **会议冲突检测**：快速发现多个日历之间的时间冲突。
- **空闲时间段检测**：使用扫描线找出会议之间的间隙。

### 📊 系统日志与事件跟踪

- **并发用户数**：计算任意时刻活跃的会话数。
- **最大负载**：跟踪最大内存/CPU使用量。

### 🗺️ 计算几何

- **线段交集**：用于地图渲染和GIS工具。
- **多边形并集/重叠检测**：对游戏物理和CAD系统有帮助。
- **构建Voronoi图**。

### 🎮 游戏开发

- **碰撞检测**：在2D游戏中，先检查物体在X轴上的重叠，再检查更耗时的Y轴。
- **渲染顺序**：基于扫描线深度的Z排序。

如果你曾经在Google日历上预定过会议，或玩过2D游戏，很可能扫描线算法在背后默默工作。

---

## 🧩 4. Leetcode题目与解法

一旦你熟悉了扫描线技术，你会发现它在许多基于区间的问题中都有应用。本节将走过一些特别适合扫描线的LeetCode题目。我们从一个经典且易于理解的题目开始：

### 📌 1854. 最大人口年份 [🔗](https://leetcode.com/problems/maximum-population-year/)

> 给定每个人的出生年份和死亡年份，返回**人口最多的最早年份**（一个人从`birth`到`death - 1`年间是活着的）。

### 🧹 扫描线如何应用

这个问题就是一个经典的例子：

- 每个人在**出生年份**时人口增加`+1`。
- 在**死亡年份**时人口减少`-1`（不包括死亡年份本身）。
- 你按**时间线事件**的顺序处理这些事件，并保持一个动态的总人口数。

它与跟踪重叠区间或会议相同——只是换成了历史情境。

### ✍️ C#解法（扫描线风格）

```csharp
public class Solution {
    public int MaximumPopulation(int[][] logs) {
        int[] years = new int[101]; // 从1950到2050

        foreach (var log in logs) {
            years[log[0] - 1950]++;   // 出生年份
            years[log[1] - 1950]--;   // 死亡年份（不包括）
        }

        int maxPop = 0, curr = 0, result = 1950;

        for (int i = 0; i < 101; i++) {
            curr += years[i];
            if (curr > maxPop) {
                maxPop = curr;
                result = 1950 + i;
            }
        }

        return result;
    }
}
```

### 📚 更多LeetCode题目

| ID    | 标题                                                | 备注                                 |
|-------|------------------------------------------------------|--------------------------------------|
| 56    | [合并区间](https://leetcode.com/problems/merge-intervals/)         | 贪心+排序（基本的扫描线思想）         |
| 1288  | [移除覆盖区间](https://leetcode.com/problems/remove-covered-intervals/) | 排序+区间消除          |
| 986   | [区间列表交集](https://leetcode.com/problems/interval-list-intersections/) | 双指针，相关思路            |
| 253   | [会议室 II](https://leetcode.com/problems/meeting-rooms-ii/)       | 扫描线与堆（进阶）      |
| 759   | [员工空闲时间](https://leetcode.com/problems/employee-free-time/)   | 合并+扫描                        |

---

## 🏁 5. 结论

**扫描线算法**是一种强大且多用途的技术，尤其适用于处理基于区间的问题。通过将区间转换为**事件**并按顺序处理这些事件，我们可以高效地处理许多现实世界的挑战，例如调度、人口分析和计算几何等。

### ✨ 关键要点

- **基于事件的思维**是扫描线算法的核心。通过将连续的区间转换为离散的事件（开始或结束点），我们可以跟踪系统的状态演变，如区间重叠或人口变化。
- **高效性**：扫描线问题通常能将暴力求解转化为更快的算法，通常通过排序和事件处理将时间复杂度从二次降低为线性。
- **常见模式**：许多LeetCode问题，从**最大人口年份**到**区间合并**，都使用了扫描线方法，这使得它成为一个值得识别和应用的重要模式。

### 🔄 什么时候使用扫描线

- 处理**区间**或**重叠事件**时。
- 需要处理大量**开始/结束时间**数据时（例如会议、日程、人口变化）。
- 寻求一种高效的方法来处理在连续时间或空间范围内的**动态变化**。

### 🚀 总结

理解并掌握扫描线技术将大大增强你的问题解决能力，使你在解决**现实世界的调度问题**和**算法挑战**时更加高效。通过将复杂的重叠问题转化为简单的事件处理任务，它是每个程序员必备的利器。
